const express = require('express');
const router = express.Router();
const Tournament = require('../models/Tournament');
const User = require('../models/User');
// Можно подключить сервис уведомлений, например:
// const emailService = require('../services/emailService');

/**
 * Функция для расчёта турнирной таблицы.
 * Для каждого участника суммируются очки (3 за победу, 1 за ничью) и разница мячей.
 */
function calculateStandings(tournament) {
  const standingsMap = {};
  tournament.players.forEach(playerId => {
    standingsMap[playerId.toString()] = { points: 0, goalDifference: 0 };
  });
  tournament.matches.forEach(match => {
    if (match.status === 'confirmed') {
      const diff = match.scoreA - match.scoreB;
      if (diff > 0) {
        standingsMap[match.playerA.toString()].points += 3;
      } else if (diff < 0) {
        standingsMap[match.playerB.toString()].points += 3;
      } else {
        standingsMap[match.playerA.toString()].points += 1;
        standingsMap[match.playerB.toString()].points += 1;
      }
      standingsMap[match.playerA.toString()].goalDifference += diff;
      standingsMap[match.playerB.toString()].goalDifference -= diff;
    }
  });
  const standings = [];
  for (const userId in standingsMap) {
    standings.push({
      userId,
      points: standingsMap[userId].points,
      goalDifference: standingsMap[userId].goalDifference
    });
  }
  standings.sort((a, b) => {
    if (b.points !== a.points) return b.points - a.points;
    return b.goalDifference - a.goalDifference;
  });
  return standings;
}

/**
 * Функция tryFinalize – вызывается после подтверждения каждого матча.
 * Если все матчи турнира имеют статус confirmed, то:
 * 1. Рассчитывается турнирная таблица.
 * 2. Определяется победитель (первый в отсортированном списке).
 * 3. Турнир переводится в статус finished, в поле winner сохраняется ID победителя, устанавливается finishedAt.
 * 4. Выполняется обновление рейтингов участников (пример: победитель +50, остальные -20).
 * 5. (Опционально) Отправляются уведомления участникам.
 */
async function tryFinalize(tournament) {
  // Проверяем, что все матчи подтверждены
  const allConfirmed = tournament.matches.every(match => match.status === 'confirmed');
  if (!allConfirmed) return;

  // Расчитываем турнирную таблицу
  const standings = calculateStandings(tournament);
  if (standings.length === 0) return;

  const winnerData = standings[0];
  tournament.status = 'finished';
  tournament.winner = winnerData.userId;
  tournament.finishedAt = new Date();
  await tournament.save();

  // Обновляем рейтинг участников – простая логика: победитель получает +50, остальные – -20.
  for (const standing of standings) {
    try {
      const user = await User.findById(standing.userId);
      if (!user) continue;
      if (standing.userId === winnerData.userId) {
        user.rating += 50;
      } else {
        user.rating -= 20;
      }
      await user.save();
      // Можно отправить уведомление, например:
      // await emailService.sendEmail(user.email, "Турнир завершён", `Ваш новый рейтинг: ${user.rating}`);
    } catch (err) {
      console.error("Ошибка обновления рейтинга для пользователя", standing.userId, err);
    }
  }
  console.log(`Турнир ${tournament._id} завершён. Победитель: ${winnerData.userId}`);
}

// Эндпоинт: Получить данные турнира
router.get('/:id', async (req, res) => {
  try {
    const tournament = await Tournament.findById(req.params.id)
      .populate('players')
      .populate('matches.playerA')
      .populate('matches.playerB');
    if (!tournament) return res.status(404).json({ message: "Турнир не найден" });
    res.json(tournament);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
});

// Эндпоинт: Получить турнирную таблицу
router.get('/:id/standings', async (req, res) => {
  try {
    const tournament = await Tournament.findById(req.params.id);
    if (!tournament) return res.status(404).json({ message: "Турнир не найден" });
    const standings = calculateStandings(tournament);
    res.json(standings);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
});

// Эндпоинт: Отправить результат матча
router.post('/:id/matches/:matchId/result', async (req, res) => {
  try {
    const { scoreA, scoreB } = req.body;
    if (scoreA === undefined || scoreB === undefined) {
      return res.status(400).json({ message: "Оба счёта должны быть указаны" });
    }
    const tournament = await Tournament.findById(req.params.id);
    if (!tournament) return res.status(404).json({ message: "Турнир не найден" });

    const match = tournament.matches.id(req.params.matchId);
    if (!match) return res.status(404).json({ message: "Матч не найден" });

    // Проверка: текущий пользователь (req.userId) должен быть одним из игроков
    if (req.userId !== match.playerA.toString() && req.userId !== match.playerB.toString()) {
      return res.status(403).json({ message: "Вы не участвуете в этом матче" });
    }

    match.scoreA = scoreA;
    match.scoreB = scoreB;
    // Статус остаётся pending до подтверждения
    await tournament.save();
    res.status(200).json({ message: "Результат матча отправлен. Ожидается подтверждение." });
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
});

// Эндпоинт: Подтвердить результат матча
router.post('/:id/matches/:matchId/confirm', async (req, res) => {
  try {
    const tournament = await Tournament.findById(req.params.id);
    if (!tournament) return res.status(404).json({ message: "Турнир не найден" });

    const match = tournament.matches.id(req.params.matchId);
    if (!match) return res.status(404).json({ message: "Матч не найден" });

    // Проверка: текущий пользователь должен быть одним из игроков
    if (req.userId !== match.playerA.toString() && req.userId !== match.playerB.toString()) {
      return res.status(403).json({ message: "Вы не участвуете в этом матче" });
    }

    if (match.confirmedBy.includes(req.userId)) {
      return res.status(400).json({ message: "Вы уже подтвердили результат" });
    }

    match.confirmedBy.push(req.userId);
    // Если подтвердили оба игрока, меняем статус матча
    if (match.confirmedBy.length >= 2) {
      match.status = 'confirmed';
    }

    await tournament.save();

    // Пытаемся завершить турнир, если все матчи подтверждены
    await tryFinalize(tournament);

    res.status(200).json({ message: "Результат матча подтверждён" });
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
});

// Эндпоинт: Создать спор по результату матча
router.post('/:id/matches/:matchId/dispute', async (req, res) => {
  try {
    const { reason } = req.body;
    const tournament = await Tournament.findById(req.params.id);
    if (!tournament) return res.status(404).json({ message: "Турнир не найден" });

    const match = tournament.matches.id(req.params.matchId);
    if (!match) return res.status(404).json({ message: "Матч не найден" });

    if (req.userId !== match.playerA.toString() && req.userId !== match.playerB.toString()) {
      return res.status(403).json({ message: "Вы не участвуете в этом матче" });
    }

    match.status = 'disputed';
    match.dispute = {
      filedBy: req.userId,
      reason: reason,
      createdAt: new Date()
    };

    await tournament.save();

    res.status(200).json({ message: "Спор создан — ожидается решение администратора" });
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
});

// Эндпоинт: Решить спор (только для администратора)
router.post('/:id/matches/:matchId/resolve', async (req, res) => {
  try {
    // Проверка: только администратор может решать споры (предполагается, что req.user.role установлен)
    if (req.user.role !== 'admin') {
      return res.status(403).json({ message: "Только администратор может решать споры" });
    }

    const { action, scoreA, scoreB } = req.body;
    const tournament = await Tournament.findById(req.params.id);
    if (!tournament) return res.status(404).json({ message: "Турнир не найден" });

    const match = tournament.matches.id(req.params.matchId);
    if (!match) return res.status(404).json({ message: "Матч не найден" });

    if (action === 'approve') {
      // При одобрении спора можно скорректировать счёт, если он передан
      if (scoreA !== undefined && scoreB !== undefined) {
        match.scoreA = scoreA;
        match.scoreB = scoreB;
      }
      match.status = 'confirmed';
      match.confirmedBy = [match.playerA, match.playerB];
      match.dispute = undefined;
    } else if (action === 'reject') {
      // При отклонении спора сбрасываем результат
      match.scoreA = 0;
      match.scoreB = 0;
      match.status = 'pending';
      match.confirmedBy = [];
      match.dispute = undefined;
    } else {
      return res.status(400).json({ message: "Недопустимое действие" });
    }

    await tournament.save();

    // Пытаемся завершить турнир, если все матчи подтверждены
    await tryFinalize(tournament);

    res.status(200).json({
      message: action === 'approve'
        ? "Спор одобрен и результат подтверждён"
        : "Спор отклонён — результат сброшен"
    });
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
});

module.exports = router;
